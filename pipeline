# .gitlab-ci.yml
# Main build, patch, and release pipeline.  Copy/paste into your repo root.

stages:
  - validate
  - lint
  - policy
  - build
  - sbom
  - scan
  - enforce
  - patch
  - rebuild
  - jmeter
  - verify
  - diff
  - release
  - notify

variables:
  IMAGE_NAME:      "$CI_REGISTRY_IMAGE"                           # e.g. registry.gitlab.com/your/project
  TAG:             "$CI_COMMIT_SHORT_SHA"
  LOGSTASH_VERSION:"9.0.3"                                       # override in CI/CD → Variables
  IMAGE_TAG:       "wolfi-${LOGSTASH_VERSION}-${TAG}"
  STABLE_TAG:      "wolfi-${LOGSTASH_VERSION}-stable"
  INITIAL_IMAGE:   "$IMAGE_NAME/unpatched:${IMAGE_TAG}"
  PATCHED_IMAGE:   "$IMAGE_NAME:${IMAGE_TAG}"
  STABLE_IMAGE:    "$IMAGE_NAME:${STABLE_TAG}"
  CONTAINERFILE:   "Containerfile"

# Certificate bundle for your custom CA
ADDITIONAL_CA_CERT_BUNDLE: |
  -----BEGIN CERTIFICATE-----
  <your CA PEM here>
  -----END CERTIFICATE-----

# 1. Validate Logstash config (your original validate stage)
validate_config:
  stage: validate
  image: docker.elastic.co/logstash/logstash:"${LOGSTASH_VERSION}"
  script:
    - echo "Validating Logstash pipeline configuration…"
    - logstash -t -f ./pipelines/

# 2. Lint Containerfile (new)
lint_containerfile:
  stage: lint
  image: hadolint/hadolint:latest
  script:
    - hadolint Containerfile

# 3. Policy enforcement (new)
policy_enforcement:
  stage: policy
  image: instrumenta/conftest:latest
  script:
    - conftest test Containerfile policies/

# 4. Build initial, unpatched image (your original build)
build_initial:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.11.0-debug
    entrypoint: [""]
  script:
    - set -e
    - mkdir -p /kaniko/ssl/certs/
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" > /kaniko/ssl/certs/additional-ca.crt
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" \
        > /kaniko/.docker/config.json
    - /kaniko/executor \
        --context "$CI_PROJECT_DIR" \
        --dockerfile "$CI_PROJECT_DIR/$CONTAINERFILE" \
        --build-arg LOGSTASH_VERSION="${LOGSTASH_VERSION}" \
        --destination "${INITIAL_IMAGE}"

# 5. Generate SBOM (new)
generate_sbom:
  stage: sbom
  image: anchore/syft:latest
  script:
    - syft "${INITIAL_IMAGE}" -o cyclonedx-json=sbom.json
  artifacts:
    paths:
      - sbom.json

# 6. Scan initial image (your original scan)
scan_initial_image:
  stage: scan
  image: aquasec/trivy:latest
  needs: ["build_initial"]
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
  script:
    - trivy image --exit-code 0 --format json   --output trivy-initial-report.json   "${INITIAL_IMAGE}"
    - trivy image --exit-code 0 --format template --template @contrib/html.tpl \
        --output trivy-initial-report.html  "${INITIAL_IMAGE}"
  artifacts:
    paths:
      - trivy-initial-report.json
      - trivy-initial-report.html

# 7. Enforce no critical vulns (new)
enforce_vuln_policy:
  stage: enforce
  image: alpine:latest
  needs: ["scan_initial_image"]
  before_script:
    - apk add --no-cache jq
  script:
    - |
      CRIT=$(jq '[.Results[].Vulnerabilities[] | select(.Severity=="CRITICAL")] | length' trivy-initial-report.json)
      if [ "$CRIT" -gt 0 ]; then
        echo "❌ $CRIT critical vulnerabilities found in initial image" && exit 1
      fi

# 8. Create patch file (your original patch logic)
generate_patch_file:
  stage: patch
  image: alpine:latest
  needs: ["enforce_vuln_policy"]
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
  script:
    - |
      echo "Generating patched Dockerfile…"
      awk '/"Vulnerabilities"/,/}/' trivy-initial-report.json \
        | jq -r '.Results[].Vulnerabilities[] | select(.PkgType=="apk") .PkgName' \
        | sort -u | xargs -r printf 'RUN apk add --no-cache %s\n' \
        > patched.Dockerfile

# 9. Rebuild with patches
rebuild_patched_image:
  stage: rebuild
  image:
    name: gcr.io/kaniko-project/executor:v1.11.0-debug
    entrypoint: [""]
  needs: ["generate_patch_file"]
  script:
    - set -e
    - mkdir -p /kaniko/ssl/certs/
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" > /kaniko/ssl/certs/additional-ca.crt
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" \
        > /kaniko/.docker/config.json
    - /kaniko/executor \
        --context "$CI_PROJECT_DIR" \
        --dockerfile "$CI_PROJECT_DIR/patched.Dockerfile" \
        --destination "${PATCHED_IMAGE}"

# 10. Performance testing (new)
performance_test:
  stage: jmeter
  image: justb4/jmeter:5.4.1
  needs: ["rebuild_patched_image"]
  script:
    - jmeter -n -t tests/pipeline_test_plan.jmx -l results.jtl
  artifacts:
    when: always
    paths:
      - results.jtl

# 11. Verify patched image (your original verify)
verify_patched_image:
  stage: verify
  image: aquasec/trivy:latest
  needs: ["performance_test"]
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL \
        --format json --output trivy-patched-report.json "${PATCHED_IMAGE}"
    - trivy image --exit-code 0 --format template --template @contrib/html.tpl \
        --output trivy-patched-report.html "${PATCHED_IMAGE}"
  artifacts:
    paths:
      - trivy-patched-report.json
      - trivy-patched-report.html

# 12. Diff images (your original diff)
diff_images:
  stage: diff
  image: alpine:latest
  needs: ["build_initial","rebuild_patched_image"]
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
    - apk add --no-cache wget
    - wget -O /usr/local/bin/container-diff \
        https://storage.googleapis.com/container-diff/latest/container-diff-linux-amd64
    - chmod +x /usr/local/bin/container-diff
  script:
    - /usr/local/bin/container-diff diff "remote://${INITIAL_IMAGE}" "remote://${PATCHED_IMAGE}" \
        --type=apk --type=layer --type=file > diff_summary.txt || true
  artifacts:
    paths:
      - diff_summary.txt

# 13. Sign image (your original sign)
sign_image:
  stage: release
  image: docker:24.0.2
  needs: ["diff_images"]
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
    - wget -qO /usr/local/bin/cosign \
        https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
    - chmod +x /usr/local/bin/cosign
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    - echo "$COSIGN_PASSWORD" | cosign generate-key-pair --passphrase-stdin cosign.key cosign.pub
    - cosign sign --key cosign.key "${PATCHED_IMAGE}"
    - cosign verify --key cosign.pub "${PATCHED_IMAGE}"
  artifacts:
    paths:
      - cosign.pub
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# 14. Promote to stable (your original promote)
promote_stable:
  stage: release
  image: alpine:latest
  needs: ["sign_image"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
    - apk add --no-cache skopeo
  script:
    - skopeo login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - skopeo copy "docker://${PATCHED_IMAGE}" "docker://${STABLE_IMAGE}"
    - echo "Promoted image → ${STABLE_IMAGE}"

# 15. Notify Slack (your original notify)
notify_slack:
  stage: notify
  image: curlimages/curl:latest
  needs: ["promote_stable"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - printf "%s\n" "$ADDITIONAL_CA_CERT_BUNDLE" >> /etc/ssl/certs/ca-certificates.crt
  script:
    - |
      curl -X POST "<SLACK_WEBHOOK_URL>" \
           -H 'Content-type: application/json' \
           -d '{
             "text":"✅ Logstash ${PATCHED_IMAGE} built, scanned, signed, and promoted to ${STABLE_IMAGE}"
           }'
